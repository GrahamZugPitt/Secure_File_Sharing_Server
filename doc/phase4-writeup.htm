<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>CS 1653 Project P4 Writeup</title>
    <style>
        /* BEGIN CHANGES HERE */

        /* In this section, you may add CSS styling if desired */
        header {
            text-align: center;
        }

        /* END CHANGES HERE */
    </style>
<body>
<header>
    <h1>CS 1653 Project P4 Writeup</h1>
    <h2>
        <!-- BEGIN CHANGES HERE -->
        Graham Zug &lt;gvz3@pitt.edu&gt;
        &nbsp;&bull;&nbsp;
        Jack Ullery &lt;jmu17@pitt.edu&gt;
        &nbsp;&bull;&nbsp;
        Taylor Kveragas &lt;tak121@pitt.edu&gt;
        <!-- END CHANGES HERE -->
    </h2>
</header>
<section id="overview">
    <h2>Overview</h2>
    <!-- BEGIN CHANGES HERE -->

    <p>In this phase, we had to protect against message manipulation, file leakage, and token theft. To mitigate
        message manipulation, we added a MAC generated by a symmetric key to the communication between our client
        and servers, and added an encrypted counter so that the client could ensure that the messages it was
        receiving were definitely received in the sequence they were supposed to be. To protect against file
        leakage we ensured that every file on every system was encrypted with a key that only the current users
        within a group have access to. When a user is removed from a group, the key is updated so any new files
        that are committed to the groups cannot be accessed by someone with the old key, however, someone with
        the old key can see files that they could have seen while they were there, the group server has the set
        of all such keys. In our previous phase, we used a hash function with an RSA signature to ensure that
        tokens were not manipulated in transit, to ensure that file servers do not steal tokens and try to use
        them on other file server, we are incorporating the file server’s public key within the hash (which is
        nique to each file server). </p>

    <!-- END CHANGES HERE -->
</section>
<section id="threat5">
    <h2>Threat T5: Message Reorder, Replay, or Modification</h2>
    <!-- BEGIN CHANGES HERE -->
    <p>This threat describes an active attacker recording messages from a session between the client and either server,
    reordering the messages, saving the messages to be replayed later, or modifying the messages. For example, an
    adversary could record the initial message sent from the client to the group server and later replay that
    message to the group server attempting to log in, an adversary could modify a message sent from the file server
    in an attempt to get a user to download a malicious fire, or an adversary could reorder an “add member” and
    “delete member” message sent to the group server in an attempt to negate the effect of the deletion of the
    member of the group. This is problematic because if messages can be successfully replayed or modified, an
    adversary could gain permissions that they are not entitled to or change the effect of the actions of
    legitimate users.</p>

    <p>The good news is, we have already largely mitigated this threat. Our current system has our group and file
    server communicate the initialization vectors they expect for the next message they receive before they
    receive it, if a server receives a message that has been reordered or replayed, it will have an
    initialization vector mismatch, and the server will immediately be able to tell. This however, leaves the
    user open to being attacked by reorder or replay attacks. However, this can only happen if an adversary
    steals a message from the same session that the user is currently in and reorders or replays it because
    each session in our model has its own symmetric key. So, in order to mitigate this threat, we will attach
    a counter to each message encrypted by the symmetric key that is shared between the server and the user,
    the server will increment this counter before it sends out its next message. If the counter is one more
    than the user remembers, the message is not a replayed or reordered message, if the counter is not one
    more than the user remembers, then the user will know the message has been reordered or replayed.</p>

    <p>To protect against tampered messages, both the server and the client will share a second symmetric key when
    initializing communication and use it to generate a MAC. The MAC will be included with every message aside from
    the first, and if the MAC does not match, the message receiver will close the connection because messages are
    being tampered with. Both the user and the server will check to see that the unencrypted message matches the
    hash when they receive a new message. This will ensure that messages are not manipulated through unsecure
    channels on both sides because an adversary cannot manipulate any message in such a way that the unencrypted
    message and the MAC will match up correctly.</p>

    <br>
    <img src="images/File_Server.png" title="T5 File Server Solution" class="image">
    </br>

    <br>
    <img src="images/Group_Server.png" title="T5 Group Server Solution" class="image">
    </br>


    <!-- END CHANGES HERE -->
</section>
<section id="threat6">
    <h2>Threat T6: File Leakage</h2>
    <!-- BEGIN CHANGES HERE -->

    <p>Our system involves untrusted file servers, which means that there is a serious threat of file leakage.
        If a file server is compromised, files could be leaked to attackers. This threat also includes the
        possibility of users accessing files from a group that they have been removed from. This is a very
        serious threat because the primary use case of our system is secure group- based file sharing with
        non-static group member lists. We need to address this threat so that only current group members can
        view their files even as group membership changes. When a user joins a group g, they must be able to
        view all current and past files that have been uploaded in g. When a user is removed from g, they must
        not be able to view any files that are uploaded to g from that point onward. Because the user could
        locally download all files before being removed from a group, we will not concern ourselves with
        preventing their being able to view the files that they had access to before their removal.</p>

    <p>We will mitigate this threat by leveraging symmetric key cryptography with the Leslie Lamport one-time
        password (OTP) scheme. At a high level, we use a symmetric key for encryption of all files on the file
        server. This key will change every time a member is removed from the group. The group server will be
        responsible for storing which index number the current key is at. To decrypt a given file f, the user
        needs the most recent key and the index of the key that was used to encrypt f. They can then derive the
        key they need to decrypt f.</p>

    <p>To implement this, we will use an AES 256 bit key in CFB block mode for encryption and decryption of files.
        When a group is created, the group server randomly generates a 256 bit symmetric key. This will be known as
        the “seed” key, or k0. We will then hash the key n = 1000 times using SHA-3 with a 256 bit message digest.
        We will call the result k_current. K_current will now be stored as the current key for group g and will be
        used for all file encryption for group g until a member is removed from the group, at which point the group
        server will update k_current by hashing k0 n-1 times. n will then be decremented by 1 to reflect this change.
        The Group Server will store k_current, n, and k0 in a group lookup table. Files that were previously encrypted
        remain unchanged.</p>

    <p>Any time a member uploads a file to the group, the file will be encrypted with key k_current. The file will be
        stored with metadata that includes the index number corresponding to the key it was encrypted with and the
        random IV that was used. When a member requests to download a file, the group server will send them an updated
        k_current and current index. If the current index number does not match the index number associated with the file,
        the user will then calculate the difference between these numbers and hash the current key that many times. The
        resultant key will be the key that was used to encrypt this file, and can now be used for decryption. Since the
        seed key is initially hashed a finite amount of times, there is the possibility of running out of new keys. In
        this event, users will no longer be able to remove group members from this group and must form a new one.</p>

    <p>Our solution is both secure and efficient. It is secure because we are using state of the art symmetric key
        cryptography techniques (AES, 256 bit key, CFB mode) to encrypt all files. Because our system model includes
        users having their access to files revoked, we need a mechanism in place to prevent them from continuing to
        decrypt files. Therefore, we use a one-time password approach where a symmetric key acts as the traditional
        notion of the password. We hash the key a finite number of times, distribute the resulting key to group
        members, and store the original only on the group server. Whenever a group member is removed, the group server
        hashes the original key one less time and redistributes to members. By keeping track of how many times the
        original key was hashed for each new key, members always have a way to derive previous keys to decrypt files
        that were encrypted before group removal operations, so long as they know the index number. This approach is
        also highly efficient because it eliminates the need for batch re encryption after each group removal operation.
    </p>

    <br>
    <img src="images/T6.png" title="T6 Solution" class="image">
    </br>


    <!-- END CHANGES HERE -->
</section>
<section id="threat7">
    <h2>Threat T7: Token Theft</h2>
    <!-- BEGIN CHANGES HERE -->

    <p>In order to prevent token theft by a FileServer. We need to create a way to cryptographically tie
        a token to a FileServer. This would ensure that the token would only be valid by the intended FileServer.</p>

    <p>We already hash and sign the contents of the token to prevent token modification/forgery. The token hash is
        signed using the private key of the group server. We only need to make a small modification to this process.
        Before the GroupServer hashes the contents of the token. It should concatenate the public RSA key of the
        FileServer to the Stringified contents of the hash. It will then hash the data and sign the encrypted hash
        using its private RSA key like before. This ensures the encrypted hash of the token cannot be modified without
        knowing the GroupServer’s private key.</p>

    <p>When the FileServer receives the token. It will verify the hash using the GroupServer’s public key like before.
        It will stringify the contents of the token and concatenate it’s own public key like the group server did. It
        will then hash this data and compare the actual hash to the verified hash. If the hashes match, there is no
        token modification or theft.This token will not be usable on another FileServer, because the verified hash is
        created using the original FileServer’s public key. If another FileServer attempts to decrypt it, they will
        generate an incorrect hash value, and they will know that the token is invalid.</p>


    <!-- END CHANGES HERE -->
</section>
<section id="discussion">
    <h2>Discussion</h2>
    <!-- BEGIN CHANGES HERE -->

    <p>Originally, we bounced back and forth arguing whether or not we had T5 covered yet or not.
        Our original approach to T5 involved simply hashing the message, encrypting the hash, and
        sending it along with the rest of the message which probably would have worked, but was
        not guaranteed to be secure. Our implementation of T6 was probably the one that we had to
        put the most thought into, as we debated between whether or not forward or backward security
        was more important and eventually settled on having backward, but not forward, security
        (i.e. new people who join the group have access to all files, but people who leave the group
        do not have access to new files, people who have left the group do have the keys to decrypt
        old files they could see while in the group, but will not have access to new files).
        The solution to T7 flowed very naturally with our phase 3 implementation. </p>

    <p>
        Threats T1-T4 are still protected against in this build. Unauthroized Token Issuance, unauthorized
        file servers, and information leakage via passive monitoring are all protected against using the
        mechanism described in the p3 write up, namely the establishment of a secure channel using the file
        or group server's symmetric keys which has not changed. And T2 is still protected against using the 
        same mechanism in the p3 write up, namely the hashing of the token and the signing of the hash from 
        the group server. 
    </p>

    <p>For extra credit, we addressed the additional threat of group servers being compromised and therefore untrusted.
        User passwords were double hashed to prevent the possibility of rainbow dictionary attacks on the group server.
        This application has a wide array of functionality and involves client and server network communications.
        With all of these moving parts, there are a multitude of both normal use and edge cases to test. Manual testing during
        phase 2 and 3 was laborious and as such exposed bugs sometimes long after they had been integrated into the codebase.
        Therefore, we have begun incorporating an automated testing into our build to alleviate the burden of manually testing
        the user client. The main test script, run_integration_tests.sh, submits an input file to be used by a Scanner object
        instead of standard input. Standard output is also rerouted to an output file, after which a simple regex checks the
        output to confirm that OK/FAIL messages were displayed to the user as expected.</p>

    <p>Instructions for running the test script are included in extra_credit.txt</p>

    <!-- END CHANGES HERE -->
</section>
</body>
</html>
